var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:sequence
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  (function () {
      "use strict";
    
      function isSequence(obj) {
        return obj instanceof Sequence;
      }
    
      function Sequence(global_context) {
        var self = this,
          waiting = true,
          data,
          stack = [];
    
        if (!isSequence(this)) {
          return new Sequence(global_context);
        }
    
        global_context = global_context || null;
    
        function next() {
          var args = Array.prototype.slice.call(arguments),
            seq = stack.shift(); // BUG this will eventually leak
    
          data = arguments;
    
          if (!seq) {
            // the chain has ended (for now)
            waiting = true;
            return;
          }
    
          args.unshift(next);
          seq.callback.apply(seq.context, args);
        }
    
        function then(callback, context) {
          if ('function' !== typeof callback) {
            throw new Error("`Sequence().then(callback [context])` requires that `callback` be a function and that `context` be `null`, an object, or a function");
          }
          stack.push({
            callback: callback,
            context: (null === context ? null : context || global_context),
            index: stack.length
          });
    
          // if the chain has stopped, start it back up
          if (waiting) {
            waiting = false;
            next.apply(null, data);
          }
    
          return self;
        }
    
        self.next = next;
        self.then = then;
      }
    
      function createSequence(context) {
        // TODO use prototype instead of new
        return (new Sequence(context));
      }
      Sequence.create = createSequence;
      Sequence.isSequence = isSequence;
      module.exports = Sequence;
    }());
    
  provide("sequence", module.exports);
}(global));

// pakmanager:querystring
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // Query String Utilities
    
    (typeof define === "undefined" ? function($) { $(require, exports, module) } : define)(function(require, exports, module, undefined) {
    "use strict";
    
    var QueryString = exports;
    
    function charCode(c) {
      return c.charCodeAt(0);
    }
    
    QueryString.unescape = decodeURIComponent;
    QueryString.escape = encodeURIComponent;
    
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case 'string':
          return v;
    
        case 'boolean':
          return v ? 'true' : 'false';
    
        case 'number':
          return isFinite(v) ? v : '';
    
        default:
          return '';
      }
    };
    
    
    QueryString.stringify = QueryString.encode = function(obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      obj = (obj === null) ? undefined : obj;
    
      switch (typeof obj) {
        case 'object':
          return Object.keys(obj).map(function(k) {
            if (Array.isArray(obj[k])) {
              return obj[k].map(function(v) {
                return QueryString.escape(stringifyPrimitive(k)) +
                       eq +
                       QueryString.escape(stringifyPrimitive(v));
              }).join(sep);
            } else {
              return QueryString.escape(stringifyPrimitive(k)) +
                     eq +
                     QueryString.escape(stringifyPrimitive(obj[k]));
            }
          }).join(sep);
    
        default:
          if (!name) return '';
          return QueryString.escape(stringifyPrimitive(name)) + eq +
                 QueryString.escape(stringifyPrimitive(obj));
      }
    };
    
    // Parse a key=val string.
    QueryString.parse = QueryString.decode = function(qs, sep, eq) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};
    
      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }
    
      qs.split(sep).forEach(function(kvp) {
        var x = kvp.split(eq);
        var k = QueryString.unescape(x[0], true);
        var v = QueryString.unescape(x.slice(1).join(eq), true);
    
        if (!(k in obj)) {
          obj[k] = v;
        } else if (!Array.isArray(obj[k])) {
          obj[k] = [obj[k], v];
        } else {
          obj[k].push(v);
        }
      });
    
      return obj;
    };
    
    });
    
  provide("querystring", module.exports);
}(global));

// pakmanager:punycode
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*! http://mths.be/punycode v1.2.0 by @mathias */
    ;(function(root) {
    
    	/**
    	 * The `punycode` object.
    	 * @name punycode
    	 * @type Object
    	 */
    	var punycode,
    
    	/** Detect free variables `define`, `exports`, `module` and `require` */
    	freeDefine = typeof define == 'function' && typeof define.amd == 'object' &&
    		define.amd && define,
    	freeExports = typeof exports == 'object' && exports,
    	freeModule = typeof module == 'object' && module,
    	freeRequire = typeof require == 'function' && require,
    
    	/** Highest positive signed 32-bit float value */
    	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
    
    	/** Bootstring parameters */
    	base = 36,
    	tMin = 1,
    	tMax = 26,
    	skew = 38,
    	damp = 700,
    	initialBias = 72,
    	initialN = 128, // 0x80
    	delimiter = '-', // '\x2D'
    
    	/** Regular expressions */
    	regexPunycode = /^xn--/,
    	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
    	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators
    
    	/** Error messages */
    	errors = {
    		'overflow': 'Overflow: input needs wider integers to process',
    		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    		'invalid-input': 'Invalid input'
    	},
    
    	/** Convenience shortcuts */
    	baseMinusTMin = base - tMin,
    	floor = Math.floor,
    	stringFromCharCode = String.fromCharCode,
    
    	/** Temporary variable */
    	key;
    
    	/*--------------------------------------------------------------------------*/
    
    	/**
    	 * A generic error utility function.
    	 * @private
    	 * @param {String} type The error type.
    	 * @returns {Error} Throws a `RangeError` with the applicable error message.
    	 */
    	function error(type) {
    		throw RangeError(errors[type]);
    	}
    
    	/**
    	 * A generic `Array#map` utility function.
    	 * @private
    	 * @param {Array} array The array to iterate over.
    	 * @param {Function} callback The function that gets called for every array
    	 * item.
    	 * @returns {Array} A new array of values returned by the callback function.
    	 */
    	function map(array, fn) {
    		var length = array.length;
    		while (length--) {
    			array[length] = fn(array[length]);
    		}
    		return array;
    	}
    
    	/**
    	 * A simple `Array#map`-like wrapper to work with domain name strings.
    	 * @private
    	 * @param {String} domain The domain name.
    	 * @param {Function} callback The function that gets called for every
    	 * character.
    	 * @returns {Array} A new string of characters returned by the callback
    	 * function.
    	 */
    	function mapDomain(string, fn) {
    		return map(string.split(regexSeparators), fn).join('.');
    	}
    
    	/**
    	 * Creates an array containing the decimal code points of each Unicode
    	 * character in the string. While JavaScript uses UCS-2 internally,
    	 * this function will convert a pair of surrogate halves (each of which
    	 * UCS-2 exposes as separate characters) into a single code point,
    	 * matching UTF-16.
    	 * @see `punycode.ucs2.encode`
    	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
    	 * @memberOf punycode.ucs2
    	 * @name decode
    	 * @param {String} string The Unicode input string (UCS-2).
    	 * @returns {Array} The new array of code points.
    	 */
    	function ucs2decode(string) {
    		var output = [],
    		    counter = 0,
    		    length = string.length,
    		    value,
    		    extra;
    		while (counter < length) {
    			value = string.charCodeAt(counter++);
    			if ((value & 0xF800) == 0xD800 && counter < length) {
    				// high surrogate, and there is a next character
    				extra = string.charCodeAt(counter++);
    				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
    					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
    				} else {
    					output.push(value, extra);
    				}
    			} else {
    				output.push(value);
    			}
    		}
    		return output;
    	}
    
    	/**
    	 * Creates a string based on an array of decimal code points.
    	 * @see `punycode.ucs2.decode`
    	 * @memberOf punycode.ucs2
    	 * @name encode
    	 * @param {Array} codePoints The array of decimal code points.
    	 * @returns {String} The new Unicode string (UCS-2).
    	 */
    	function ucs2encode(array) {
    		return map(array, function(value) {
    			var output = '';
    			if (value > 0xFFFF) {
    				value -= 0x10000;
    				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
    				value = 0xDC00 | value & 0x3FF;
    			}
    			output += stringFromCharCode(value);
    			return output;
    		}).join('');
    	}
    
    	/**
    	 * Converts a basic code point into a digit/integer.
    	 * @see `digitToBasic()`
    	 * @private
    	 * @param {Number} codePoint The basic (decimal) code point.
    	 * @returns {Number} The numeric value of a basic code point (for use in
    	 * representing integers) in the range `0` to `base - 1`, or `base` if
    	 * the code point does not represent a value.
    	 */
    	function basicToDigit(codePoint) {
    		return codePoint - 48 < 10
    			? codePoint - 22
    			: codePoint - 65 < 26
    				? codePoint - 65
    				: codePoint - 97 < 26
    					? codePoint - 97
    					: base;
    	}
    
    	/**
    	 * Converts a digit/integer into a basic code point.
    	 * @see `basicToDigit()`
    	 * @private
    	 * @param {Number} digit The numeric value of a basic code point.
    	 * @returns {Number} The basic code point whose value (when used for
    	 * representing integers) is `digit`, which needs to be in the range
    	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
    	 * used; else, the lowercase form is used. The behavior is undefined
    	 * if flag is non-zero and `digit` has no uppercase form.
    	 */
    	function digitToBasic(digit, flag) {
    		//  0..25 map to ASCII a..z or A..Z
    		// 26..35 map to ASCII 0..9
    		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    	}
    
    	/**
    	 * Bias adaptation function as per section 3.4 of RFC 3492.
    	 * http://tools.ietf.org/html/rfc3492#section-3.4
    	 * @private
    	 */
    	function adapt(delta, numPoints, firstTime) {
    		var k = 0;
    		delta = firstTime ? floor(delta / damp) : delta >> 1;
    		delta += floor(delta / numPoints);
    		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
    			delta = floor(delta / baseMinusTMin);
    		}
    		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    	}
    
    	/**
    	 * Converts a basic code point to lowercase if `flag` is falsy, or to
    	 * uppercase if `flag` is truthy. The code point is unchanged if it's
    	 * caseless. The behavior is undefined if `codePoint` is not a basic code
    	 * point.
    	 * @private
    	 * @param {Number} codePoint The numeric value of a basic code point.
    	 * @returns {Number} The resulting basic code point.
    	 */
    	function encodeBasic(codePoint, flag) {
    		codePoint -= (codePoint - 97 < 26) << 5;
    		return codePoint + (!flag && codePoint - 65 < 26) << 5;
    	}
    
    	/**
    	 * Converts a Punycode string of ASCII code points to a string of Unicode
    	 * code points.
    	 * @memberOf punycode
    	 * @param {String} input The Punycode string of ASCII code points.
    	 * @returns {String} The resulting string of Unicode code points.
    	 */
    	function decode(input) {
    		// Don't use UCS-2
    		var output = [],
    		    inputLength = input.length,
    		    out,
    		    i = 0,
    		    n = initialN,
    		    bias = initialBias,
    		    basic,
    		    j,
    		    index,
    		    oldi,
    		    w,
    		    k,
    		    digit,
    		    t,
    		    length,
    		    /** Cached calculation results */
    		    baseMinusT;
    
    		// Handle the basic code points: let `basic` be the number of input code
    		// points before the last delimiter, or `0` if there is none, then copy
    		// the first basic code points to the output.
    
    		basic = input.lastIndexOf(delimiter);
    		if (basic < 0) {
    			basic = 0;
    		}
    
    		for (j = 0; j < basic; ++j) {
    			// if it's not a basic code point
    			if (input.charCodeAt(j) >= 0x80) {
    				error('not-basic');
    			}
    			output.push(input.charCodeAt(j));
    		}
    
    		// Main decoding loop: start just after the last delimiter if any basic code
    		// points were copied; start at the beginning otherwise.
    
    		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
    
    			// `index` is the index of the next character to be consumed.
    			// Decode a generalized variable-length integer into `delta`,
    			// which gets added to `i`. The overflow checking is easier
    			// if we increase `i` as we go, then subtract off its starting
    			// value at the end to obtain `delta`.
    			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
    
    				if (index >= inputLength) {
    					error('invalid-input');
    				}
    
    				digit = basicToDigit(input.charCodeAt(index++));
    
    				if (digit >= base || digit > floor((maxInt - i) / w)) {
    					error('overflow');
    				}
    
    				i += digit * w;
    				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    
    				if (digit < t) {
    					break;
    				}
    
    				baseMinusT = base - t;
    				if (w > floor(maxInt / baseMinusT)) {
    					error('overflow');
    				}
    
    				w *= baseMinusT;
    
    			}
    
    			out = output.length + 1;
    			bias = adapt(i - oldi, out, oldi == 0);
    
    			// `i` was supposed to wrap around from `out` to `0`,
    			// incrementing `n` each time, so we'll fix that now:
    			if (floor(i / out) > maxInt - n) {
    				error('overflow');
    			}
    
    			n += floor(i / out);
    			i %= out;
    
    			// Insert `n` at position `i` of the output
    			output.splice(i++, 0, n);
    
    		}
    
    		return ucs2encode(output);
    	}
    
    	/**
    	 * Converts a string of Unicode code points to a Punycode string of ASCII
    	 * code points.
    	 * @memberOf punycode
    	 * @param {String} input The string of Unicode code points.
    	 * @returns {String} The resulting Punycode string of ASCII code points.
    	 */
    	function encode(input) {
    		var n,
    		    delta,
    		    handledCPCount,
    		    basicLength,
    		    bias,
    		    j,
    		    m,
    		    q,
    		    k,
    		    t,
    		    currentValue,
    		    output = [],
    		    /** `inputLength` will hold the number of code points in `input`. */
    		    inputLength,
    		    /** Cached calculation results */
    		    handledCPCountPlusOne,
    		    baseMinusT,
    		    qMinusT;
    
    		// Convert the input in UCS-2 to Unicode
    		input = ucs2decode(input);
    
    		// Cache the length
    		inputLength = input.length;
    
    		// Initialize the state
    		n = initialN;
    		delta = 0;
    		bias = initialBias;
    
    		// Handle the basic code points
    		for (j = 0; j < inputLength; ++j) {
    			currentValue = input[j];
    			if (currentValue < 0x80) {
    				output.push(stringFromCharCode(currentValue));
    			}
    		}
    
    		handledCPCount = basicLength = output.length;
    
    		// `handledCPCount` is the number of code points that have been handled;
    		// `basicLength` is the number of basic code points.
    
    		// Finish the basic string - if it is not empty - with a delimiter
    		if (basicLength) {
    			output.push(delimiter);
    		}
    
    		// Main encoding loop:
    		while (handledCPCount < inputLength) {
    
    			// All non-basic code points < n have been handled already. Find the next
    			// larger one:
    			for (m = maxInt, j = 0; j < inputLength; ++j) {
    				currentValue = input[j];
    				if (currentValue >= n && currentValue < m) {
    					m = currentValue;
    				}
    			}
    
    			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
    			// but guard against overflow
    			handledCPCountPlusOne = handledCPCount + 1;
    			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
    				error('overflow');
    			}
    
    			delta += (m - n) * handledCPCountPlusOne;
    			n = m;
    
    			for (j = 0; j < inputLength; ++j) {
    				currentValue = input[j];
    
    				if (currentValue < n && ++delta > maxInt) {
    					error('overflow');
    				}
    
    				if (currentValue == n) {
    					// Represent delta as a generalized variable-length integer
    					for (q = delta, k = base; /* no condition */; k += base) {
    						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
    						if (q < t) {
    							break;
    						}
    						qMinusT = q - t;
    						baseMinusT = base - t;
    						output.push(
    							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
    						);
    						q = floor(qMinusT / baseMinusT);
    					}
    
    					output.push(stringFromCharCode(digitToBasic(q, 0)));
    					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
    					delta = 0;
    					++handledCPCount;
    				}
    			}
    
    			++delta;
    			++n;
    
    		}
    		return output.join('');
    	}
    
    	/**
    	 * Converts a Punycode string representing a domain name to Unicode. Only the
    	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
    	 * matter if you call it on a string that has already been converted to
    	 * Unicode.
    	 * @memberOf punycode
    	 * @param {String} domain The Punycode domain name to convert to Unicode.
    	 * @returns {String} The Unicode representation of the given Punycode
    	 * string.
    	 */
    	function toUnicode(domain) {
    		return mapDomain(domain, function(string) {
    			return regexPunycode.test(string)
    				? decode(string.slice(4).toLowerCase())
    				: string;
    		});
    	}
    
    	/**
    	 * Converts a Unicode string representing a domain name to Punycode. Only the
    	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
    	 * matter if you call it with a domain that's already in ASCII.
    	 * @memberOf punycode
    	 * @param {String} domain The domain name to convert, as a Unicode string.
    	 * @returns {String} The Punycode representation of the given domain name.
    	 */
    	function toASCII(domain) {
    		return mapDomain(domain, function(string) {
    			return regexNonASCII.test(string)
    				? 'xn--' + encode(string)
    				: string;
    		});
    	}
    
    	/*--------------------------------------------------------------------------*/
    
    	/** Define the public API */
    	punycode = {
    		/**
    		 * A string representing the current Punycode.js version number.
    		 * @memberOf punycode
    		 * @type String
    		 */
    		'version': '1.2.0',
    		/**
    		 * An object of methods to convert from JavaScript's internal character
    		 * representation (UCS-2) to decimal Unicode code points, and back.
    		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
    		 * @memberOf punycode
    		 * @type Object
    		 */
    		'ucs2': {
    			'decode': ucs2decode,
    			'encode': ucs2encode
    		},
    		'decode': decode,
    		'encode': encode,
    		'toASCII': toASCII,
    		'toUnicode': toUnicode
    	};
    
    	/** Expose `punycode` */
    	if (freeExports) {
    		if (freeModule && freeModule.exports == freeExports) {
    			// in Node.js or Ringo 0.8+
    			freeModule.exports = punycode;
    		} else {
    			// in Narwhal or Ringo 0.7-
    			for (key in punycode) {
    				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    			}
    		}
    	} else if (freeDefine) {
    		// via curl.js or RequireJS
    		define('punycode', punycode);
    	} else {
    		// in a browser or Rhino
    		root.punycode = punycode;
    	}
    
    }(this));
  provide("punycode", module.exports);
}(global));

// pakmanager:forEachAsync
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true*/
    (function () {
      "use strict";
    
      var Sequence = require('sequence');
    
      function handleItem(item, i, arr) {
        var seq = this
          ;
    
        function nextItem(next, BREAK) {
          if (forEachAsync.BREAK === BREAK) {
            process.nextTick(function () {
              next(forEachAsync.BREAK);
            });
            return;
          }
    
          seq._contextCallback.call(this, next, item, i, arr);
        }
    
        seq.then(nextItem);
      }
    
      function forEachAsync(arr, callback, _context) {
        var sequence = Sequence.create(_context);
    
        sequence._contextCallback = callback;
    
        arr.forEach(handleItem, sequence);
    
        return sequence;
      }
    
      forEachAsync.BREAK = '__forEachAsync_BREAK__';
      module.exports = forEachAsync;
    }());
    
  provide("forEachAsync", module.exports);
}(global));

// pakmanager:events.node as events
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  if ('undefined' === typeof process) {
      process = {};
    }
    (function () {
      "use strict";
    
      process.EventEmitter = process.EventEmitter || function () {};
    
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var EventEmitter = exports.EventEmitter = process.EventEmitter;
    var isArray = Array.isArray;
    
    // By default EventEmitters will print a warning if more than
    // 10 listeners are added to it. This is a useful default which
    // helps finding memory leaks.
    //
    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    var defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!this._events) this._events = {};
      this._events.maxListeners = n;
    };
    
    
    EventEmitter.prototype.emit = function(type) {
      // If there is no 'error' event listener then throw.
      if (type === 'error') {
        if (!this._events || !this._events.error ||
            (isArray(this._events.error) && !this._events.error.length))
        {
          if (arguments[1] instanceof Error) {
            throw arguments[1]; // Unhandled 'error' event
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
          return false;
        }
      }
    
      if (!this._events) return false;
      var handler = this._events[type];
      if (!handler) return false;
    
      if (typeof handler == 'function') {
        switch (arguments.length) {
          // fast cases
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            var args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
        return true;
    
      } else if (isArray(handler)) {
        var args = Array.prototype.slice.call(arguments, 1);
    
        var listeners = handler.slice();
        for (var i = 0, l = listeners.length; i < l; i++) {
          listeners[i].apply(this, args);
        }
        return true;
    
      } else {
        return false;
      }
    };
    
    // EventEmitter is defined in src/node_events.cc
    // EventEmitter.prototype.emit() is also defined there.
    EventEmitter.prototype.addListener = function(type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('addListener only takes instances of Function');
      }
    
      if (!this._events) this._events = {};
    
      // To avoid recursion in the case that type == "newListeners"! Before
      // adding it to the listeners, first emit "newListeners".
      this.emit('newListener', type, listener);
    
      if (!this._events[type]) {
        // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;
      } else if (isArray(this._events[type])) {
    
        // If we've already got an array, just append.
        this._events[type].push(listener);
    
        // Check for listener leak
        if (!this._events[type].warned) {
          var m;
          if (this._events.maxListeners !== undefined) {
            m = this._events.maxListeners;
          } else {
            m = defaultMaxListeners;
          }
    
          if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error('(node) warning: possible EventEmitter memory ' +
                          'leak detected. %d listeners added. ' +
                          'Use emitter.setMaxListeners() to increase limit.',
                          this._events[type].length);
            console.trace();
          }
        }
      } else {
        // Adding the second element, need to change to array.
        this._events[type] = [this._events[type], listener];
      }
    
      return this;
    };
    
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    
    EventEmitter.prototype.once = function(type, listener) {
      var self = this;
      function g() {
        self.removeListener(type, g);
        listener.apply(this, arguments);
      };
    
      g.listener = listener;
      self.on(type, g);
    
      return this;
    };
    
    EventEmitter.prototype.removeListener = function(type, listener) {
      if ('function' !== typeof listener) {
        throw new Error('removeListener only takes instances of Function');
      }
    
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events || !this._events[type]) return this;
    
      var list = this._events[type];
    
      if (isArray(list)) {
        var position = -1;
        for (var i = 0, length = list.length; i < length; i++) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener))
          {
            position = i;
            break;
          }
        }
    
        if (position < 0) return this;
        list.splice(position, 1);
        if (list.length == 0)
          delete this._events[type];
      } else if (list === listener ||
                 (list.listener && list.listener === listener))
      {
        delete this._events[type];
      }
    
      return this;
    };
    
    EventEmitter.prototype.removeAllListeners = function(type) {
      // does not use listeners(), so no side effect of creating _events[type]
      if (type && this._events && this._events[type]) this._events[type] = null;
      return this;
    };
    
    EventEmitter.prototype.listeners = function(type) {
      if (!this._events) this._events = {};
      if (!this._events[type]) this._events[type] = [];
      if (!isArray(this._events[type])) {
        this._events[type] = [this._events[type]];
      }
      return this._events[type];
    };
    
    }());
    
  provide("events.node", module.exports);
  provide("events", module.exports);
  $.ender(module.exports);
}(global));

// pakmanager:url
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
    (function () {
      "use strict";
    
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    var punycode = require('punycode');
    
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    
    // Reference: RFC 3986, RFC 1808, RFC 2396
    
    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,
    
        // RFC 2396: characters reserved for delimiting URLs.
        // We actually just auto-escape these.
        delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    
        // RFC 2396: characters not allowed for various reasons.
        unwise = ['{', '}', '|', '\\', '^', '~', '`'].concat(delims),
    
        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
        autoEscape = ['\''].concat(delims),
        // Characters that are never ever allowed in a hostname.
        // Note that any invalid chars are also handled, but these
        // are the ones that are *expected* to be seen, so we fast-path
        // them.
        nonHostChars = ['%', '/', '?', ';', '#']
          .concat(unwise).concat(autoEscape),
        nonAuthChars = ['/', '@', '?', '#'].concat(delims),
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
        hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
        // protocols that can allow "unsafe" and "unwise" chars.
        unsafeProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that never have a hostname.
        hostlessProtocol = {
          'javascript': true,
          'javascript:': true
        },
        // protocols that always have a path component.
        pathedProtocol = {
          'http': true,
          'https': true,
          'ftp': true,
          'gopher': true,
          'file': true,
          'http:': true,
          'ftp:': true,
          'gopher:': true,
          'file:': true
        },
        // protocols that always contain a // bit.
        slashedProtocol = {
          'http': true,
          'https': true,
          'ftp': true,
          'gopher': true,
          'file': true,
          'http:': true,
          'https:': true,
          'ftp:': true,
          'gopher:': true,
          'file:': true
        },
        querystring = require('querystring');
    
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && typeof(url) === 'object' && url.href) return url;
    
      if (typeof url !== 'string') {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
    
      var out = {},
          rest = url;
    
      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();
    
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        out.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
    
      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          out.slashes = true;
        }
      }
    
      if (!hostlessProtocol[proto] &&
          (slashes || (proto && !slashedProtocol[proto]))) {
        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        // don't enforce full RFC correctness, just be unstupid about it.
    
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the first @ sign, unless some non-auth character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        var atSign = rest.indexOf('@');
        if (atSign !== -1) {
          var auth = rest.slice(0, atSign);
    
          // there *may be* an auth
          var hasAuth = true;
          for (var i = 0, l = nonAuthChars.length; i < l; i++) {
            if (auth.indexOf(nonAuthChars[i]) !== -1) {
              // not a valid auth.  Something like http://foo.com/bar@baz/
              hasAuth = false;
              break;
            }
          }
    
          if (hasAuth) {
            // pluck off the auth portion.
            out.auth = decodeURIComponent(auth);
            rest = rest.substr(atSign + 1);
          }
        }
    
        var firstNonHost = -1;
        for (var i = 0, l = nonHostChars.length; i < l; i++) {
          var index = rest.indexOf(nonHostChars[i]);
          if (index !== -1 &&
              (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
        }
    
        if (firstNonHost !== -1) {
          out.host = rest.substr(0, firstNonHost);
          rest = rest.substr(firstNonHost);
        } else {
          out.host = rest;
          rest = '';
        }
    
        // pull out port.
        var p = parseHost(out.host);
        var keys = Object.keys(p);
        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          out[key] = p[key];
        }
    
        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        out.hostname = out.hostname || '';
    
        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = out.hostname[0] === '[' &&
            out.hostname[out.hostname.length - 1] === ']';
    
        // validate a little.
        if (out.hostname.length > hostnameMaxLen) {
          out.hostname = '';
        } else if (!ipv6Hostname) {
          var hostparts = out.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                out.hostname = validParts.join('.');
                break;
              }
            }
          }
        }
    
        // hostnames are always lower case.
        out.hostname = out.hostname.toLowerCase();
    
        if (!ipv6Hostname) {
          // IDNA Support: Returns a puny coded representation of "domain".
          // It only converts the part of the domain name that
          // has non ASCII characters. I.e. it dosent matter if
          // you call it with a domain that already is in ASCII.
          var domainArray = out.hostname.split('.');
          var newOut = [];
          for (var i = 0; i < domainArray.length; ++i) {
            var s = domainArray[i];
            newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
                'xn--' + punycode.encode(s) : s);
          }
          out.hostname = newOut.join('.');
        }
    
        out.host = (out.hostname || '') +
            ((out.port) ? ':' + out.port : '');
        out.href += out.host;
    
        // strip [ and ] from the hostname
        if (ipv6Hostname) {
          out.hostname = out.hostname.substr(1, out.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }
    
      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {
    
        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
    
    
      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        out.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        out.search = rest.substr(qm);
        out.query = rest.substr(qm + 1);
        if (parseQueryString) {
          out.query = querystring.parse(out.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        out.search = '';
        out.query = {};
      }
      if (rest) out.pathname = rest;
      if (slashedProtocol[proto] &&
          out.hostname && !out.pathname) {
        out.pathname = '/';
      }
    
      //to support http.request
      if (out.pathname || out.search) {
        out.path = (out.pathname ? out.pathname : '') +
                   (out.search ? out.search : '');
      }
    
      // finally, reconstruct the href based on what has been validated.
      out.href = urlFormat(out);
      return out;
    }
    
    // format a parsed object into a url string
    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (typeof(obj) === 'string') obj = urlParse(obj);
    
      var auth = obj.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }
    
      var protocol = obj.protocol || '',
          pathname = obj.pathname || '',
          hash = obj.hash || '',
          host = false,
          query = '';
    
      if (obj.host !== undefined) {
        host = auth + obj.host;
      } else if (obj.hostname !== undefined) {
        host = auth + (obj.hostname.indexOf(':') === -1 ?
            obj.hostname :
            '[' + obj.hostname + ']');
        if (obj.port) {
          host += ':' + obj.port;
        }
      }
    
      if (obj.query && typeof obj.query === 'object' &&
          Object.keys(obj.query).length) {
        query = querystring.stringify(obj.query);
      }
    
      var search = obj.search || (query && ('?' + query)) || '';
    
      if (protocol && protocol.substr(-1) !== ':') protocol += ':';
    
      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (obj.slashes ||
          (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }
    
      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;
    
      return protocol + host + pathname + search + hash;
    }
    
    function urlResolve(source, relative) {
      return urlFormat(urlResolveObject(source, relative));
    }
    
    function urlResolveObject(source, relative) {
      if (!source) return relative;
    
      source = urlParse(urlFormat(source), false, true);
      relative = urlParse(urlFormat(relative), false, true);
    
      // hash is always overridden, no matter what.
      source.hash = relative.hash;
    
      if (relative.href === '') {
        source.href = urlFormat(source);
        return source;
      }
    
      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        relative.protocol = source.protocol;
        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[relative.protocol] &&
            relative.hostname && !relative.pathname) {
          relative.path = relative.pathname = '/';
        }
        relative.href = urlFormat(relative);
        return relative;
      }
    
      if (relative.protocol && relative.protocol !== source.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          relative.href = urlFormat(relative);
          return relative;
        }
        source.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          relative.pathname = relPath.join('/');
        }
        source.pathname = relative.pathname;
        source.search = relative.search;
        source.query = relative.query;
        source.host = relative.host || '';
        source.auth = relative.auth;
        source.hostname = relative.hostname || relative.host;
        source.port = relative.port;
        //to support http.request
        if (source.pathname !== undefined || source.search !== undefined) {
          source.path = (source.pathname ? source.pathname : '') +
                        (source.search ? source.search : '');
        }
        source.slashes = source.slashes || relative.slashes;
        source.href = urlFormat(source);
        return source;
      }
    
      var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
          isRelAbs = (
              relative.host !== undefined ||
              relative.pathname && relative.pathname.charAt(0) === '/'
          ),
          mustEndAbs = (isRelAbs || isSourceAbs ||
                        (source.host && relative.pathname)),
          removeAllDots = mustEndAbs,
          srcPath = source.pathname && source.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = source.protocol &&
              !slashedProtocol[source.protocol];
    
      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // source.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
    
        delete source.hostname;
        delete source.port;
        if (source.host) {
          if (srcPath[0] === '') srcPath[0] = source.host;
          else srcPath.unshift(source.host);
        }
        delete source.host;
        if (relative.protocol) {
          delete relative.hostname;
          delete relative.port;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;
            else relPath.unshift(relative.host);
          }
          delete relative.host;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }
    
      if (isRelAbs) {
        // it's absolute.
        source.host = (relative.host || relative.host === '') ?
                          relative.host : source.host;
        source.hostname = (relative.hostname || relative.hostname === '') ?
                          relative.hostname : source.hostname;
        source.search = relative.search;
        source.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        source.search = relative.search;
        source.query = relative.query;
      } else if ('search' in relative) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          source.hostname = source.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especialy happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = source.host && source.host.indexOf('@') > 0 ?
                           source.host.split('@') : false;
          if (authInHost) {
            source.auth = authInHost.shift();
            source.host = source.hostname = authInHost.shift();
          }
        }
        source.search = relative.search;
        source.query = relative.query;
        //to support http.request
        if (source.pathname !== undefined || source.search !== undefined) {
          source.path = (source.pathname ? source.pathname : '') +
                        (source.search ? source.search : '');
        }
        source.href = urlFormat(source);
        return source;
      }
      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        delete source.pathname;
        //to support http.request
        if (!source.search) {
          source.path = '/' + source.search;
        } else {
          delete source.path;
        }
        source.href = urlFormat(source);
        return source;
      }
      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (
          (source.host || relative.host) && (last === '.' || last === '..') ||
          last === '');
    
      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last == '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
    
      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }
    
      if (mustEndAbs && srcPath[0] !== '' &&
          (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }
    
      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('');
      }
    
      var isAbsolute = srcPath[0] === '' ||
          (srcPath[0] && srcPath[0].charAt(0) === '/');
    
      // put the host back
      if (psychotic) {
        source.hostname = source.host = isAbsolute ? '' :
                                        srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = source.host && source.host.indexOf('@') > 0 ?
                         source.host.split('@') : false;
        if (authInHost) {
          source.auth = authInHost.shift();
          source.host = source.hostname = authInHost.shift();
        }
      }
    
      mustEndAbs = mustEndAbs || (source.host && srcPath.length);
    
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }
    
      source.pathname = srcPath.join('/');
      //to support request.http
      if (source.pathname !== undefined || source.search !== undefined) {
        source.path = (source.pathname ? source.pathname : '') +
                      (source.search ? source.search : '');
      }
      source.auth = relative.auth || source.auth;
      source.slashes = source.slashes || relative.slashes;
      source.href = urlFormat(source);
      return source;
    }
    
    function parseHost(host) {
      var out = {};
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          out.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) out.hostname = host;
      return out;
    }
    
    }());
    
  provide("url", module.exports);
  $.ender(module.exports);
}(global));

// pakmanager:anr/inherits
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true unused:true undef:true*/
    (function () {
      "use strict";
    
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    
      module.exports = inherits;
    }());
    
  provide("anr/inherits", module.exports);
}(global));

// pakmanager:anr/anr-request-browser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true unused:true undef:true*/
    (function () {
      "use strict";
    
      var inherits =  require('anr/inherits')
        , url = require('url')
        , events = require('events')
        , forEachAsync = require('forEachAsync')
        , XMLHttpRequest = require('XMLHttpRequest')
        //, FormData = require('FormData')
        , p
          // only show error once per instantiation
        , headerExceptions = {}
        ;
    
      function AnrRequest(prequest, wares, context) {
        var me = this
          ;
    
        events.EventEmitter.call(this);
    
        this.context = context;
        this.accept = [];
        this.headers = {};
        this.prequestWares = prequest;
        this.wares = wares;
        this.total = Infinity;
        this.loaded = 0;
        this._futures = [];
        this._requestCreated = false;
        this._requestSent = false;
        this._xhrData = "";
    
        this.when = function (fn) {
          if (me._fulfilled) {
            fn(me._error, me.context._response, me.context._response.body);
          }
          me._futures.push(fn);
    
          return me;
        };
        this.on('pipe', function () {
          throw new Error('[AREQ] TODO implement `pipe`');
        });
      }
    
      // TODO stream
      inherits(AnrRequest, events.EventEmitter);
    
      p = AnrRequest.prototype;
      p.abort = function () {
        // NOTE: again, it's the response object that makes the request
        return this._xhrResponse.abort();
      };
      p.setTimeout = function (t, fn) {
        // http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute
        this._xhrResponse.timeout = t;
        this._xhrResponse.on('timeout', fn);
      };
      p._prequest = function () {
        var me = this
          ;
    
        // TODO get some callback for other todo
        forEachAsync(me.prequestWares, me._handleHandler, me).then(function () {
          console.log('[AREQ] handled prequest headers');
          process.nextTick(function () {
            me._sendHeaders();
            console.log('[AREQ] sent headers');
            // default to built-in write method
            forEachAsync(me.wares, me._handleHandler, me).then(me._defaultWrite);
          });
        });
      };
      p._handleHandler = function (next, fn) {
        console.log('[AREQ] handling a request handler...');
        fn(this, next);
      };
      p.write = function (data, encoding) {
        // NOTE: If a module wants to do some sort of transformation before actually
        // writing the data, it can overload this write function:
        // var origWrite = req.write;
        // req.write = function (chunk) { origWrite.apply(req, chunk); }
        // TODO handle binary buffers
        this._xhrData += data;
    
        // NOTE: technically this should return false
        // However, since it all buffers until send and then buffers out
        // it returns true to prevent pipe / drain / pause / resume hangups
        return true;
      };
      p.end = function (data, encoding) {
        var me = this
          ;
    
        if (me._requestSent) {
          console.error('Request already sent');
          return;
        }
    
        if (data) {
          this.write(data, encoding);
        }
    
        // TODO do any binary buffer concatonation
        me._requestSent = true;
        me._xhrResponse.send(me._xhrData);
      };
      // TODO rename this to createRequest or something.
      // XHR sends headers and data all at once (abstracted by the browser)
      p._sendHeaders = function () {
        var me = this
          , options = this.context._options
          ;
    
        if (this._requestCreated) {
          console.warn('already sent request');
          return;
        } else {
          this._requestCreated = true;
        }
    
        /*
         * host
         * hostname
         * port
         * localAddress
         * socketPath
         * method
         * path
         * headers
         * auth
         * agent
         */
    
        // http://w3.org/TR/XMLHttpRequest/#event-handlers
        // http://w3.org/TR/XMLHttpRequest/#events
        /*
         * readystatechange
         *
         * loadstart
         * progress
         * abort
         * error
         * load
         * timeout
         * loadend
         */
        // html5rocks.com/en/tutorials/file/xhr2/
    
        // NOTE: xhrResponse is the request object for historical reasons.
        me._xhrResponse = new XMLHttpRequest();
        me._xhrResponse.on = me._xhrResponse.addEventListener;
        me._xhrResponse.on('progress', function () {
          if (!me.context.loadstarted) {
            me.context.loadstarted = true;
            me.context._response._start(me._xhrResponse);
          }
        });
    
        me._xhrRequest = me._xhrResponse.upload;
        me._xhrRequest.on = me._xhrRequest.addEventListener;
        me._xhrRequest.on('loadstart', function (err) {
          me.emit('error', err);
        });
        me._xhrRequest.on('progress', function (ev) {
          me.lengthComputable = ev.lengthComputable;
          me.loaded = ev.loaded;
          me.total = ev.total;
          me.emit('progress', ev);
        });
        me._xhrRequest.on('abort', function () {
          me.emit('abort');
        });
        me._xhrRequest.on('error', function (ev) {
          // TODO abstract error into a real error
          me.emit('error', ev);
        });
        me._xhrRequest.on('load', function () {
          me.emit('load');
          me.emit('end');
        });
        me._xhrRequest.on('timeout', function () {
          me.emit('timeout');
        });
        me._xhrRequest.on('loadend', function () {
          me.emit('loadend');
        });
    
        options.href = url.format(options);
        // NOTE: just in case href was added but the host is the current host
        if (options.protocol && (!options.host && !options.hostname)) {
          options.href = options.href.replace(/^[\w\-]*:/, '');
        }
    
        if (options.auth) {
          options.authArr = options.auth.substr(':');
          me._xhrResponse.open(options.method, options.href, true, options.authArr[0], options.authArr[1]);
        } else {
          me._xhrResponse.open(options.method, options.href, true);
        }
        // TODO settable withcredentials
        //me._xhrResponse.withCredentials = true;
        Object.keys(options.headers).forEach(function (key) {
          try {
            me._xhrResponse.setRequestHeader(key, options.headers[key]);
          } catch(e) {
            if (headerExceptions[key]) {
              return;
            }
    
            console.error("Could not set header '" + key + "' to '" + options.headers[key] + "'");
            console.error(e);
            headerExceptions[key] = true;
          }
        });
      };
      p._defaultWrite = function () {
        console.log('[AREQ] default Write');
        // TODO progress for loaded
        var me = this
          , options = this.context._options
          ;
    
        if (null === options.body) {
          me.end();
          return;
        }
    
        if (undefined === options.body) {
          console.log('[AREQ] body not handled, waiting for req.end()');
          return;
        }
    
        if ('function' === typeof options.body.pipe) {
          options.body.pipe(this).on('end', function () {
            me.end();
          });
          return;
        }
    
        if (('string' === typeof options.body)) { // || (options.body instanceof Buffer)) {
          me.end(options.body);
          return;
        }
    
        // takes care of Object, Array, Boolean, and Number
        me.end(JSON.stringify(options.body));
      };
    
      module.exports = AnrRequest;
    }());
    
  provide("anr/anr-request-browser", module.exports);
}(global));

// pakmanager:anr/anr-response-browser
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true unused:true undef:true*/
    (function () {
      "use strict";
    
      var inherits =  require('anr/inherits')
        , events = require('events')
        , forEachAsync = require('forEachAsync')
        , p
        ;
    
      function AnrResponse(wares, context) {
        events.EventEmitter.call(this);
    
        this.context = context;
        // no modification
        this._headers = {};
        // lowercase
        this.headers = {};
        this.wares = wares;
        this.total = Infinity;
        this.loaded = 0;
        this.statusCode = null;
        this._chunks = [];
      }
    
      // TODO stream
      inherits(AnrResponse, events.EventEmitter);
    
      p = AnrResponse.prototype;
      p._fulfill = function () {
        var me = this
          ;
    
        me.context._request._futures.forEach(function (fn) {
          fn(this._error, this.context._request, this.body);
        }, me);
        me.context._request._fulfilled = true;
      };
      p._start = function (res) {
        var me = this
          ;
    
        // http://w3.org/TR/XMLHttpRequest/#event-handlers
        // http://w3.org/TR/XMLHttpRequest/#events
        /*
         * readystatechange
         *
         * loadstart
         * progress
         * abort
         * error
         * load
         * timeout
         * loadend
         */
        // html5rocks.com/en/tutorials/file/xhr2/
        // headers have been received
        me._xhrResponse = res;
    
        // this event is already representative of loadstart
        //res.addEventListener('loadstart', function () {
          me.emit('loadstart');
        //});
        res.on = res.addEventListener;
        res.on('progress', function (ev) {
          me.lengthComputable = ev.lengthComputable;
          me.loaded = ev.loaded;
          me.total = ev.total;
        });
        res.on('abort', function () {
          me.emit('abort');
        });
        res.on('error', function (ev) {
          me.completed = true;
          me.emit('error', ev);
        });
        res.on('load', function () {
          var body = res.response
            ;
          // "", "arraybuffer", "blob", "document", "json", "text"
          me.resultType = res.responseType;
          // response responseText responseXML
    
          me.completed = true;
          me.emit('data', body);
          me.emit('end');
          me.body = res.body || res.response;
          me.emit('load');
          me.emit('close');
        });
        res.on('timeout', function () {
          me.emit('timeout');
        });
        res.on('loadend', function () {
          me.emit('loadend');
        });
        // XHR doesn't have data and end events
        //res.on('data', function (chunk) {});
        //res.on('end', function () {});
        //res.on('close', function () {});
    
        //me.status = res.status;
        me.statusCode = res.status;
        me.statusText = res.statusText;
        me.rawHeaders = res.getAllResponseHeaders().trim();
        me.rawHeaders.split(/[\r\n]+/g).forEach(function (str) {
          var pair = str.split(/:/)
            ;
    
          me.headers[pair.shift().trim().toLowerCase()] = pair.join(':').trim();
        });
    
        forEachAsync(me.wares, me._handleHandler, me).then(function () {
          console.log('[ARES] not handled by any of the wares, giving way to `response` handler.');
          me.context._request.emit('response', me.context._response);
          if (me.completed) {
            me._fulfill();
          } else {
            /*
            me.on('data', function (chunk) {
              me._chunks.push(chunk);
            });
            */
            me.on('end', function () {
              //me.body = Buffer.concat(me.chunks);
              me.fulfill();
            });
          }
        });
      };
      p.pause = function () {
        // This is already abstracted by the browser for XHR
        return;
      };
      p.resume = function () {
        // This is already abstracted by the browser for XHR
        return;
      };
      p._handleHandler = function (next, fn) {
        console.log('[ARES] handling a response handler...');
        fn(this, next);
      };
    
      module.exports = AnrResponse;
    }());
    
  provide("anr/anr-response-browser", module.exports);
}(global));

// pakmanager:anr/http-shortcuts
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
    (function () {
      "use strict";
    
      function addShortcuts(Anr) {
        Anr.prototype._abstractHttp = function (method, urlStr, query, body) {
          console.log('[SHORT] abstractHttp');
          return this.http(urlStr, { method: method, query: query, body: body });
        };
        Anr.prototype.https = function (options) {
          console.log('[SHORT] https');
          options.secure = true;
          return this.http(options);
        };
        Anr.prototype.get = function (url, query) {
          console.log('[SHORT] get');
          return this._abstractHttp('get', url, query);
        };
        Anr.prototype.post = function (url, query, body) {
          console.log('[SHORT] post');
          return this._abstractHttp('post', url, query, body);
        };
        Anr.prototype.patch = function (url, query, body) {
          console.log('[SHORT] patch');
          return this._abstractHttp('patch', url, query, body);
        };
        Anr.prototype.put = function (url, query, body) {
          console.log('[SHORT] put');
          return this._abstractHttp('put', url, query, body);
        };
        // bracket notation for ES3 backwards compat
        Anr.prototype['delete'] = function (url, query, body) {
          console.log('[SHORT] delete');
          return this._abstractHttp('delete', url, query, body);
        };
        // alternate method for ES3 backwards compat
        Anr.prototype.del = Anr.prototype['delete'];
      }
    
      module.exports = function () {
        return addShortcuts;
      };
    }());
    
  provide("anr/http-shortcuts", module.exports);
}(global));

// pakmanager:anr/http-json
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true undef:true unused:true*/
    (function () {
      "use strict";
    
      function json(anr) {
        anr.for('prequest', function (req, next) {
          /*jshint sub:true*/
          var accept = req.headers['accept']
            ;
    
          // text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5
          if (!accept) {
            req.headers['accept'] = "";
          }
    
          // TODO handle accept header with array where the first is the most desired???
          if (!/json/.test(accept)) {
            if (accept) {
              req.headers['accept'] += ', application/json;q=0.5';
            } else {
              req.headers['accept'] += 'application/json;q=1.0';
            }
          }
    
          console.log('[JSON] matched prequest');
          next();
        });
    
        anr.for('response', function (res, next) {
          console.log('[JSON] attempt response -----------------------------------');
          var data = ''
            ;
    
          if (res.__json) {
            next();
            return;
          }
          res.__json = true;
    
          console.log('[JSON] headers');
          console.log(res.headers);
          if (!/json/.test(res.headers['content-type'])) {
            console.log('[JSON] skip: no json in content-type');
            next();
            return;
          }
    
          res.on('data', function (chunk) {
            console.log('[JSON] data');
            data += chunk.toString();
          });
    
          res.on('end', function () {
            console.log('[JSON] end');
            try {
              res.body = JSON.parse(data);
            } catch(e) {
              res.error = e;
              res.body = data;
            }
            next();
          });
        });
      }
    
      module.exports = function () {
        return json;
      };
    }());
    
  provide("anr/http-json", module.exports);
}(global));

// pakmanager:anr/http-text
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
    (function () {
      "use strict";
    
      function text(anr) {
        anr.for('prequest', function (req, next) {
          /*jshint sub:true*/
          var accept = req.headers['accept']
            ;
    
          // text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5
          if (!accept) {
            req.headers['accept'] = "";
          }
    
          // TODO handle accept header with array where the first is the most desired???
          if (!/text/.test(accept)) {
            if (accept) {
              req.headers['accept'] += ', text/plain;q=0.5';
            } else {
              req.headers['accept'] += 'text/plain;q=1.0';
            }
          }
    
          console.log('[TEXT] matched prequest');
          next();
        });
    
        anr.for('response', function (res, next) {
          console.log('[TEXT] attempt response -----------------------------------');
          var data = ''
            ;
    
          if (res.__text) {
            next();
            return;
          }
          res.__text = true;
    
          if (!/text/.test(res.headers['content-type'])) {
            console.log('[TEXT] skip: no text in content-type');
            next();
            return;
          }
    
          res.on('data', function (chunk) {
            console.log('[TEXT] onData', chunk);
            data += chunk;
          });
    
          res.on('end', function () {
            console.log('[TEXT] onEnd');
            res.body = data;
            next();
          });
        });
      }
    
      module.exports = function () {
        return text;
      };
    }());
    
  provide("anr/http-text", module.exports);
}(global));

// pakmanager:anr
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true unused:true undef:true*/
    (function () {
      "use strict";
    
      process.nextTick = global.setImmediate || function (fn) {
        setTimeout(fn, 0);
      };
    
      var inherits =  require('anr/inherits')
        , url = require('url')
        , events = require("events")
        , AnrRequest =  require('anr/anr-request-browser')
        , AnrResponse =  require('anr/anr-response-browser')
        , anr
        , key
        ;
    
      function request(a, b, c, d, e) {
        var req = new Anr()
          ;
    
        return req.http(a, b, c, d, e);
      }
    
      function Anr() {
        if (!(this instanceof Anr)) {
          return request.appy(null, arguments);
        }
    
        events.EventEmitter.call(this);
        this._anr_proto_ = Anr.prototype;
        this._wares = [];
        this._prequestWares = [];
        this._requestWares = [];
        this._responseWares = [];
      }
    
      inherits(Anr, events.EventEmitter);
    
      Anr.prototype.extend = function (fn) {
        if ('function' !== typeof fn) {
          console.error('extend fn:', fn);
          throw new Error('extend must receive a function');
        }
        fn(Anr);
        return this;
      };
      Anr.prototype.use = function () {
        var args = Array.prototype.slice.call(arguments)
          , fn
          , mount
          , host
          ;
    
        args.forEach(function (arg) {
          if ('function' === typeof arg) {
            fn = arg;
          } else if (/^\//.test(arg)) {
            mount = arg;
          } else if (/^\w+:/i.test(arg)) {
            host = arg;
          } else {
            throw new Error('Bad Argument ' + arg);
          }
        });
    
        // on('request', fn)
        this._wares.push([host, mount, fn]);
        return this;
      };
      Anr.prototype.for = function (type, fn) {
        if ('prequest' === type) {
          this._prequestWares.push(fn);
        } else if ('request' === type) {
          this._requestWares.push(fn);
        } else if ('response' === type) {
          this._responseWares.push(fn);
        } else {
          throw new Error('`for` can only accept functions for `prequest`, `request` and `response`.');
        }
      };
      // Unlike previous versions of AHR, this does not modify the original options
      Anr.prototype._parse = function (urlStr, options) {
        var urlObj
          , query
          ;
    
        options = options || {};
        if ('string' !== typeof urlStr) {
          options = urlStr;
        }
    
        urlStr = options.url || options.uri || options.href || urlStr;
        query = options.query || {};
    
        urlObj = url.parse(urlStr, true, true);
        urlObj.search = null;
    
        if (options.user || options.username || options.pass || options.password) {
          urlObj.auth = urlObj.auth || (options.user || options.username || '') + ':' + (options.pass || options.password || '');
        }
    
        Object.keys(query).forEach(function (key) {
          urlObj.query[key] = options.query[key];
        });
        options.query = null;
    
        Object.keys(urlObj).forEach(function (key) {
          var val = options[key]
            ;
    
          // don't replace something with '', undefined, null
          // but do replace for 0, false
          if (null === val || 'undefined' === typeof val || '' === val) {
            return;
          }
    
          urlObj[key] = options[key];
        });
    
        urlObj.headers = urlObj.headers || {};
        // TODO restrict some headers
    
        urlObj.body = options.body;
        urlObj.method = urlObj.method || 'GET';
        urlObj.method = urlObj.method.toUpperCase();
    
        if ('GET' === urlObj.method) {
          if (!urlObj.forceGetBody) {
            if (urlObj.body) {
              throw new Error(
                  'refusing to set a body for a GET. use `forceGetBody: true` to force\n'
                + '(Your browser will probably strip the body or convert it to a POST)'
              );
            }
            urlObj.body = null;
          }
        }
        
        return urlObj;
      };
      Anr.prototype.http = function (urlStr, options) {
        console.log('[CORE] http');
        var context = {}
          , request
          , response
          ;
    
        context._options = this._parse(urlStr, options);
        request = new AnrRequest(this._prequestWares, this._requestWares, context);
        response = new AnrResponse(this._responseWares, context);
    
        context._request = request;
        context._response = response;
        
        console.log('[CORE] wares');
        this._wares.forEach(function (ware) {
          var fn = ware[2]
            , mount = ware[1]
            , host = ware[0]
            , urlObj
            ;
    
          if (host) {
            urlObj = url.parse(host);
            host = urlObj.host || host;
            if (!(context._options.host||"").match(host)) {
              console.log('[WARE] host skip', host, context._options.host);
              return;
            }
          }
    
          if (mount && !(context._options.pathname||"").match(mount)) {
            console.log('[WARE] mount skip', mount, context._options.pathname);
            return;
          }
    
          console.log('[WARE] matched for ', host, mount, JSON.stringify(fn.toString().substr(0, 30)));
          fn(this);
        }, this);
    
        request._prequest();
        return request;
      };
    
      Anr.create = function (a, b, c) {
        return new Anr(a, b, c);
      };
    
      // Backwards compat trickery
      anr = Anr.create();
      anr.create = Anr.create;
      anr.Http =  require('anr/http-shortcuts');
      anr.json =  require('anr/http-json');
      anr.text =  require('anr/http-text');
      anr.extend(anr.Http());
    
      function ahr(a, b, c, d, e) {
        return anr.http(a, b, c, d, e);
      }
    
      // copy over the prototype methods as well
      for (key in anr) {
        ahr[key] = anr[key];
      }
    
      module.exports = ahr;
    }());
    
  provide("anr", module.exports);
}(global));